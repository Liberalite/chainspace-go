package api

import (
	"encoding/json"
	"net/http"

	_ "chainspace.io/prototype/examples/cs-coin/api/docs"
	"chainspace.io/prototype/examples/cs-coin/service"
	sbacapi "chainspace.io/prototype/sbac/api"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"
)

type Router struct {
	*gin.Engine
	srv *service.Service
}

// @title cs-coin API
// @version 1.0
// @description cs-coin methods and checker endpoints
// @termsOfService http://swagger.io/terms/

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

func New() *Router {
	r := Router{
		Engine: gin.Default(),
		srv:    service.New(),
	}
	r.Use(cors.Default())

	// swagger docs
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// contracts methods
	r.GET("/api/cs-coin/wallet/init/:address", r.createWallet)
	r.POST("/api/cs-coin/wallet", r.createWallet)
	r.POST("/api/cs-coin/wallet/add-funds", r.addFunds)
	r.POST("/api/cs-coin/wallet/transfer-funds", r.transferFunds)

	// checkers
	r.POST("/cs-coin/create-wallet", r.createWalletChecker)
	r.POST("/cs-coin/add-funds", r.addFundsChecker)
	r.POST("/cs-coin/transfer-funds", r.TransferFundsChecker)

	// healthcheck
	r.GET("/healthcheck", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"ok": true})
	})
	return &r
}

// init Generate the seed object
// @Summary Generate the seed object for a new wallet
// @Description Generate the seed object for a new wallet
// @ID init
// @Accept  json
// @Produce  json
// @Tags cs-coin-init
// @Param   addr      path   string     true  "addr"
// @Success 200 {object} api.InitResponse
// @Router /api/cs-coin/wallet/init/{addr} [get]
func (r *Router) init(c *gin.Context) {
	addr := c.Param("addr")
	res := InitResponse{
		InitObject: r.srv.Init(addr),
	}
	c.JSON(http.StatusOK, res)
}

// createWallet Create a new Wallet from address generated by the user
// @Summary Create a new Wallet from address generated by the user
// @Description Create a new Wallet from address generated by the user
// @ID createWallet
// @Accept  json
// @Produce  json
// @Tags cs-coin-methods
// @Param   wallet      body   api.CreateWalletRequest     true  "wallet"
// @Success 200 {object} api.Response
// @Success 400 {object} api.Response
// @Success 500 {object} api.Response
// @Router /api/cs-coin/wallet [post]
func (r *Router) createWallet(c *gin.Context) {
	req := CreateWalletRequest{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	tx, err := r.srv.CreateWallet(req.Address, req.PubKey, req.InitObject, req.Mappings)
	if err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	c.JSON(http.StatusOK,
		Response{Transaction: *tx})
}

// addFunds Add new funds to a user wallet
// @Summary Add new funds to a user wallet
// @Description Add new funds to user wallet
// @ID addFunds
// @Accept  json
// @Produce  json
// @Tags cs-coin-methods
// @Param   request      body   api.AddFundsRequest     true  "request"
// @Success 200 {object} api.Response
// @Success 400 {object} api.Response
// @Success 500 {object} api.Response
// @Router /api/cs-coin/wallet/add-funds [post]
func (r *Router) addFunds(c *gin.Context) {
	req := AddFundsRequest{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	// unmarshal wallets from mappings
	walletStr, ok := req.Mappings[req.Wallet]
	if !ok {
		c.JSON(http.StatusBadRequest,
			Response{Error: "missing fromWallet in mappings"})
		return
	}
	wallet := service.Wallet{}
	err := json.Unmarshal([]byte(walletStr), &wallet)
	if err != nil {
		c.JSON(http.StatusBadRequest,
			Response{Error: err.Error()})
		return
	}

	tx, err := r.srv.AddFunds(wallet, req.Amount, req.Signature, req.Mappings,
		req.Wallet)
	if err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	c.JSON(http.StatusOK,
		Response{Transaction: *tx})
}

// transferFunds Transfer funds
// @Summary Transfer funds from a wallet to another
// @Description Transfer funds from a wallet to another
// @ID transferFunds
// @Accept  json
// @Produce  json
// @Tags cs-coin-methods
// @Param   request      body   api.TransferFundsRequest     true  "request"
// @Success 200 {object} api.Response
// @Success 400 {object} api.Response
// @Success 500 {object} api.Response
// @Router /api/cs-coin/wallet/transfer-funds [post]
func (r *Router) transferFunds(c *gin.Context) {
	req := TransferFundsRequest{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	// unmarshal wallets from mappings
	fromWalletStr, ok := req.Mappings[req.FromWallet]
	if !ok {
		c.JSON(http.StatusBadRequest,
			Response{Error: "missing fromWallet in mappings"})
		return
	}
	fromWallet := service.Wallet{}
	err := json.Unmarshal([]byte(fromWalletStr), &fromWallet)
	if err != nil {
		c.JSON(http.StatusBadRequest,
			Response{Error: err.Error()})
		return
	}

	toWalletStr, ok := req.Mappings[req.FromWallet]
	if !ok {
		c.JSON(http.StatusBadRequest,
			Response{Error: "missing toWallet in mappings"})
		return
	}
	toWallet := service.Wallet{}
	err = json.Unmarshal([]byte(toWalletStr), &toWallet)
	if err != nil {
		c.JSON(http.StatusBadRequest,
			Response{Error: err.Error()})
		return
	}

	tx, err := r.srv.TransferFunds(fromWallet, toWallet, req.Amount,
		req.Signature, req.Mappings, req.FromWallet, req.ToWallet)
	if err != nil {
		c.JSON(http.StatusInternalServerError,
			Response{Error: err.Error()})
		return
	}

	c.JSON(http.StatusOK,
		Response{Transaction: *tx})

}

func (r *Router) createWalletChecker(c *gin.Context) {
	req := sbacapi.Transaction{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	ok := r.srv.CreateWalletChecker(&req)

	c.JSON(http.StatusOK, CheckerResponse{Success: ok})
}

func (r *Router) addFundsChecker(c *gin.Context) {
	req := sbacapi.Transaction{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	ok := r.srv.AddFundsChecker(&req)

	c.JSON(http.StatusOK, CheckerResponse{Success: ok})

}

func (r *Router) TransferFundsChecker(c *gin.Context) {
	req := sbacapi.Transaction{}
	if err := c.BindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, Response{Error: err.Error()})
		return
	}

	ok := r.srv.TransferFundsChecker(&req)

	c.JSON(http.StatusOK, CheckerResponse{Success: ok})

}
