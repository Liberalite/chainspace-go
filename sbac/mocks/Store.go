// Code generated by mockery v1.0.0. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"
import sbac "chainspace.io/chainspace-go/sbac"

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// AddTransaction provides a mock function with given fields: txkey, value
func (_m *Store) AddTransaction(txkey []byte, value []byte) error {
	ret := _m.Called(txkey, value)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte) error); ok {
		r0 = rf(txkey, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Close provides a mock function with given fields:
func (_m *Store) Close() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CommitTransaction provides a mock function with given fields: txnkey, inobjkeys, objs
func (_m *Store) CommitTransaction(txnkey []byte, inobjkeys [][]byte, objs []*sbac.Object) error {
	ret := _m.Called(txnkey, inobjkeys, objs)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, [][]byte, []*sbac.Object) error); ok {
		r0 = rf(txnkey, inobjkeys, objs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateObject provides a mock function with given fields: vid, value
func (_m *Store) CreateObject(vid []byte, value []byte) (*sbac.Object, error) {
	ret := _m.Called(vid, value)

	var r0 *sbac.Object
	if rf, ok := ret.Get(0).(func([]byte, []byte) *sbac.Object); ok {
		r0 = rf(vid, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sbac.Object)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(vid, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateObjects provides a mock function with given fields: objs
func (_m *Store) CreateObjects(objs []*sbac.Object) error {
	ret := _m.Called(objs)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*sbac.Object) error); ok {
		r0 = rf(objs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeactivateObjects provides a mock function with given fields: keys
func (_m *Store) DeactivateObjects(keys [][]byte) error {
	ret := _m.Called(keys)

	var r0 error
	if rf, ok := ret.Get(0).(func([][]byte) error); ok {
		r0 = rf(keys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteObjects provides a mock function with given fields: objkeys
func (_m *Store) DeleteObjects(objkeys [][]byte) error {
	ret := _m.Called(objkeys)

	var r0 error
	if rf, ok := ret.Get(0).(func([][]byte) error); ok {
		r0 = rf(objkeys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FinishTransaction provides a mock function with given fields: txnkey
func (_m *Store) FinishTransaction(txnkey []byte) error {
	ret := _m.Called(txnkey)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(txnkey)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetObjects provides a mock function with given fields: vids
func (_m *Store) GetObjects(vids [][]byte) ([]*sbac.Object, error) {
	ret := _m.Called(vids)

	var r0 []*sbac.Object
	if rf, ok := ret.Get(0).(func([][]byte) []*sbac.Object); ok {
		r0 = rf(vids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*sbac.Object)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([][]byte) error); ok {
		r1 = rf(vids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransaction provides a mock function with given fields: txkey
func (_m *Store) GetTransaction(txkey []byte) ([]byte, bool, error) {
	ret := _m.Called(txkey)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte) []byte); ok {
		r0 = rf(txkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func([]byte) bool); ok {
		r1 = rf(txkey)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func([]byte) error); ok {
		r2 = rf(txkey)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// LockObjects provides a mock function with given fields: objkeys
func (_m *Store) LockObjects(objkeys [][]byte) error {
	ret := _m.Called(objkeys)

	var r0 error
	if rf, ok := ret.Get(0).(func([][]byte) error); ok {
		r0 = rf(objkeys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TxnFinished provides a mock function with given fields: txnkey
func (_m *Store) TxnFinished(txnkey []byte) (bool, error) {
	ret := _m.Called(txnkey)

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte) bool); ok {
		r0 = rf(txnkey)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(txnkey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnlockObjects provides a mock function with given fields: objkeys
func (_m *Store) UnlockObjects(objkeys [][]byte) error {
	ret := _m.Called(objkeys)

	var r0 error
	if rf, ok := ret.Get(0).(func([][]byte) error); ok {
		r0 = rf(objkeys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
